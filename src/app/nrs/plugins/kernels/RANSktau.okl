void SSTBlendingFunc(const dfloat rho, 
                     const dfloat mueLam,
                     const dfloat k,
                     const dfloat tau,
                     const dfloat stmag2,
                     const dfloat xk,
                     const dfloat yw,
                     dfloat &f1,
                     dfloat &mut)
{
  f1 = 1.0;
  mut = 0.0;

  if(yw > p_tiny) {
    const dfloat k2 = sqrt(k);
    const dfloat nu = mueLam / rho;

    const dfloat iyd = 1.0 / yw;
    const dfloat iyd2 = iyd * iyd;

    const dfloat arg2_1 = k2 * tau * iyd / p_betainf_str;
    const dfloat arg2_2 = 500.0 * nu * tau * iyd2;
    const dfloat arg1_1 = fmax(arg2_1, arg2_2);

    const dfloat arg2 = fmax(2.0 * arg2_1, arg2_2);
    const dfloat arg2sq = arg2 * arg2;
    const dfloat f2 = tanh(arg2sq);

    dfloat arg1_2 = 4.0 * p_sigom2 * k * iyd2 / p_tinySST;
    const dfloat arg1c = 2.0 * p_sigom2 * xk;
    const dfloat ptau = p_tinySST * tau;
    if(arg1c > ptau)
        arg1_2 = 2.0 * k * tau * iyd2 / xk; 

    const dfloat arg1 = fmin(arg1_1, arg1_2);
    const dfloat arg1_4 = arg1 * arg1 * arg1 * arg1;
    f1 = tanh(arg1_4);

    mut = rho * k * tau;
    const dfloat stmagn = sqrt(2.0 * stmag2);
    const dfloat argn = f2 * stmagn; 
    const dfloat argtau = argn * tau;
    if(p_alp1 < argtau) mut = rho * p_alp1 * k / argn;
  }
}

@kernel void mue(const dlong N,
                 const dlong offset,
                 const dfloat rho,
                 const dfloat mueLam,
                 const dlong ifktau,
                 @ restrict const dfloat *K,
                 @ restrict const dfloat *TAU,
                 @ restrict const dfloat *STMAG2,
                 @ restrict const dfloat *XK,
                 @ restrict const dfloat *YWD,
                 @ restrict dfloat *MUET,
                 @ restrict dfloat *MUE,
                 @ restrict dfloat *DIFF)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner))
    if (n < N) {
      const dfloat k = K[n];
      const dfloat tau = TAU[n];

      dfloat mut = 0.0;
      dfloat sigk, sigom;
      if(ifktau){
        mut = rho * p_alpinf_str * k * tau;
        sigk = p_sigma_k;
        sigom = p_sigma_tau;
      }
      else{
        const dfloat yw = YWD[n];
        const dfloat stmag2 = STMAG2[n];
        const dfloat xk = XK[n];
        dfloat f1 = 1.0;
        SSTBlendingFunc(rho, mueLam, k, tau, stmag2, xk, yw, f1, mut);
        const dfloat f11 = 1.0 - f1;
        sigk = f1 * p_sigmak_SST + f11 * p_sigk2;
        sigom = f1 * p_sigma_tau + f11 * p_sigom2;
      }

      MUET[n] = mut;

      MUE[n] = mueLam + mut;
      DIFF[n + 0 * offset] = mueLam + sigk * mut;
      DIFF[n + 1 * offset] = mueLam + sigom * mut;
    }
}

@kernel void RANSktauCompute(const dlong N,
                             const dlong offset,
                             const dlong ifktau,
                             const dlong ifdes,
                             const dfloat rho,
                             const dfloat mue,
                             @ restrict const dfloat *K,
                             @ restrict const dfloat *TAU,
                             @ restrict const dfloat *STMAG2,
                             @ restrict const dfloat *OIOJSK,
                             @ restrict const dfloat *XK,
                             @ restrict const dfloat *XT,
                             @ restrict const dfloat *XTQ,
                             @ restrict const dfloat *DGRD,
                             @ restrict const dfloat *YWD,
                             @ restrict const dfloat *OMAG2,
                             @ restrict dfloat *SRCDIAG,
                             @ restrict dfloat *SRC)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner)) {
    if(n < N) {
      const dfloat xk = XK[n];
      const dfloat xt = XT[n];
      const dfloat xtq = XTQ[n];

      const dfloat stMag2 = STMAG2[n];
      const dfloat OiOjSk = OIOJSK[n];

      const dfloat kk = K[n];
      const dfloat tau = TAU[n];

      dfloat mu_t = 0.0;
      dfloat Y_k = 0.0;
      dfloat Rfact = 1.0;
      dfloat Y_w = 0.0;
      dfloat S_w0 = 0.0;
      dfloat G_wp = 0.0;
      dfloat sigom = 0.0;
      dfloat beta = 0.0;
      dfloat itau = 0.0;
      if (tau > 0.0)
        itau = 1.0 / (tau + p_tiny);

      if(ifktau) {
        mu_t = rho * p_alpinf_str * kk * tau;
        dfloat sigd = p_sigd_min;
        dfloat f_beta_str = 1.0;
        if (xk > 0.0) {
          const dfloat xk3 = xk * xk * tau * tau;
          sigd = p_sigd_max;
          f_beta_str = (1.0 + p_fb_c1st * xk3) / (1.0 + p_fb_c2st * xk3);
        }
        const dfloat x_w = fabs(OiOjSk) * (tau * tau * tau * p_ibetainf_str3);
        const dfloat f_b = (p_pope) ? (1.0 + p_fb_c1 * x_w) / (1.0 + p_fb_c2 * x_w) : 1.0;
        Y_k = rho * p_betainf_str * f_beta_str * itau;
        Y_w = -rho * p_beta0 * f_b;
        S_w0 = -rho * sigd *xk;
        G_wp = rho * p_alp_inf * tau * 2.0 * stMag2;
        sigom = p_alpinf_str * p_sigma_tau;
        beta = p_beta0;
      }
      else{
        const dfloat yw = YWD[n];
        dfloat f1 = 1.0;
        SSTBlendingFunc(rho, mue, kk, tau, stMag2, xk, yw, f1, mu_t);
    
        const dfloat mu_min = p_edd_free * mue;
        if(mu_t < mu_min && yw > p_ywlim) 
          Rfact = mu_t / mu_min;

        const dfloat f11 = 1.0 - f1;
        beta = f1 * p_beta0_SST + f11 * p_beta2;
        const dfloat gamma = f1 * p_alpinf_SST + f11 * p_gamma2;
        sigom = f1 * p_sigma_tau + f11 * p_sigom2;
    
        Y_k = rho * p_betainf_str * Rfact * itau;
                
        if(ifdes){
          const dfloat cdes = f1 * p_cdes1 + f11 * p_cdes2;

          const dfloat k2 = sqrt(kk);
          const dfloat ransL = k2 * (tau + p_tiny) / p_betainf_str;

          const dlong ide = n / p_Np;
          const dfloat hmax = DGRD[ide];
          dfloat dscle = hmax;
          if(ifdes == 2){
              const dfloat dscl1 = 0.15 * fmax(yw, hmax);
              dscle = fmin(dscl1, hmax);
          }
          const dfloat xlesL = cdes * dscle;

          const dfloat omag2 = OMAG2[n];
          const dfloat sqStOm = sqrt(stMag2 + omag2);
          const dfloat ykap = p_vkappa * yw;
          const dfloat ykap2 = ykap * ykap;
          const dfloat denom_rd = ykap2 * sqStOm;
          const dfloat xnut = mu_t / rho;
          const dfloat xnul = mue / rho;
          const dfloat xnueff = xnut + xnul;
          dfloat rdt = 0.0;
          if(denom_rd > p_tiny){
              rdt = xnueff / denom_rd;
              if(ifdes == 2) rdt = xnut / denom_rd;
          }
          const dfloat cd12 = pow(p_cd1 * rdt, p_cd2);
          const dfloat fdt = 1.0 - tanh(cd12);
          dfloat ddesL = ransL - fdt * fmax(0.0, ransL - xlesL);
      
          if(ifdes == 2){
              dfloat rdl = 0.0;
              if(denom_rd > p_tiny) rdl = xnul / denom_rd;
              const dfloat alcon = 0.25 - yw / hmax;
              const dfloat alcon2 = alcon * alcon;
              const dfloat fb1 = -9.0 * alcon2;
              const dfloat fb = fmin(2.0 * exp(fb1), 1.0);
              const dfloat fd = fmax(1 - fdt, fb);
              dfloat fe1 = 2.0 * exp(fb1);
              if(alcon > 0.0) fe1 = 2.0 * exp(-11.09 * alcon2);
              const dfloat ft = tanh(pow(3.4969 * rdt, 3.0));
              const dfloat fl = tanh(pow(25.0 * rdl, 10.0));
              const dfloat fe2 = 1.0 - fmax(ft, fl);
              const dfloat fe = fe2 * fmax(fe1 - 1.0, 0.0);
        
              ddesL = fd * (1 + fe) * ransL + (1 - fd) * xlesL;
          }
      
          Y_k = 0.0;
          if(ddesL > 0.0) Y_k = rho * k2 / ddesL;
        }
        Y_w = -rho * beta * Rfact;
        if(xk > 0.0) S_w0 = -2.0 * rho * p_sigom2 * f11 * xk * Rfact;
        G_wp = rho * gamma * tau * 2.0 * stMag2 * Rfact;
      }

      const dfloat kSrc = fmin(mu_t * 2*stMag2, 10.0f * Y_k * kk);
      const dfloat kDiag = Y_k;

      // compute source term for tau
      const dfloat tau_max = 8.0 * beta / 3.0;
      const dfloat S_tau = fmin(8.0f * mue * xtq, tau_max) * Rfact;
      const dfloat S_taup = 8.0 * rho * kk * xtq * sigom * Rfact;     

      dfloat tauSrc = 0.0;
      dfloat tauDiag = 0.0;

      if(tau < p_tiny){
        tauSrc = -Y_w - S_tau;
        tauDiag = G_wp - S_w0 + S_taup;
      }
      else{
        tauSrc = -Y_w;
        tauDiag = G_wp - S_w0 + S_taup + S_tau * itau;
      }
      SRC[n + 0 * offset] = kSrc;
      SRC[n + 1 * offset] = tauSrc;
      SRCDIAG[n + 0 * offset] = kDiag;
      SRCDIAG[n + 1 * offset] = tauDiag;
    }
  }
}

@kernel void limit(const dlong N,
                   @restrict dfloat* K,
                   @restrict dfloat* TAU)
{
  for(dlong n = 0; n < N; ++n; @tile(p_blockSize,@outer,@inner))
    if(n < N) {
      dfloat k   = K[n];
      dfloat tau = TAU[n];
      if(k < 0) k = 0.001 * fabs(k);
      if(tau < 0) tau = 0.001 * fabs(tau);
      
      K[n] = k;
      TAU[n] = tau;
    }
}

@kernel void SijMag2OiOjSk(const dlong N,
                           const dlong offset,
                           const dlong ifOij,
                           @ restrict const dfloat *SOIJ,
                           @ restrict dfloat *OIOJSK,
                           @ restrict dfloat *MAGSIJ)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner))
    if (n < N) {
      const dfloat s1 = SOIJ[n + 0 * offset];
      const dfloat s2 = SOIJ[n + 3 * offset];
      const dfloat s3 = SOIJ[n + 5 * offset];
      const dfloat s4 = SOIJ[n + 1 * offset];
      const dfloat s5 = SOIJ[n + 4 * offset];
      const dfloat s6 = SOIJ[n + 2 * offset];

      const dfloat o1 = SOIJ[n + 8 * offset];
      const dfloat o2 = SOIJ[n + 7 * offset];
      const dfloat o3 = SOIJ[n + 6 * offset];

      const dfloat magSij = s1 * s1 + s2 * s2 + s3 * s3 + 2 * (s4 * s4 + s5 * s5 + s6 * s6);
      MAGSIJ[n] = magSij;

      if (ifOij) {
        const dfloat OiOjSk = s1 * (o2 * o2 + o3 * o3) + s2 * (o1 * o1 + o3 * o3) + s3 * (o1 * o1 + o2 * o2) +
                              2 * (o1 * o2 * s4 + o2 * o3 * s5 - o1 * o3 * s6);
        OIOJSK[n] = 8*OiOjSk;
      }
    }
}

@kernel void RANSGradHex3D(const dlong Nelements,
                           const dlong offset,
                           @ restrict const dfloat *vgeo,
                           @ restrict const dfloat *D,
                           @ restrict const dfloat *K,
                           @ restrict const dfloat *TAU,
                           @ restrict dfloat *XK,
                           @ restrict dfloat *XT,
                           @ restrict dfloat *XTQ)
{
  for (dlong e = 0; e < Nelements; ++e; @outer(0)) {
    @shared dfloat s_k[p_Nq][p_Nq];
    @shared dfloat s_tau[p_Nq][p_Nq];
    @shared dfloat s_tauSqrt[p_Nq][p_Nq];
    @exclusive dfloat s_kloc[p_Nq];
    @exclusive dfloat s_tauloc[p_Nq];
    @exclusive dfloat s_tauSqrtloc[p_Nq];

    @shared dfloat s_D[p_Nq][p_Nq];

#pragma unroll p_Nq
    for (int k = 0; k < p_Nq; ++k) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          dlong id = i + j * p_Nq;
          if (k == 0)
            s_D[0][id] = D[id];

          id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          const dfloat kn = K[id];
          const dfloat taun = TAU[id];

          s_k[j][i] = kn;
          s_tau[j][i] = taun;
          s_tauSqrt[j][i] = sqrt(taun);
          if (k == 0) {
#pragma unroll p_Nq
            for (int l = 0; l < p_Nq; ++l) {
              const dlong other_id = e * p_Np + l * p_Nq * p_Nq + j * p_Nq + i;
              const dfloat lockn = K[other_id];
              const dfloat loctaun = TAU[other_id];
              s_kloc[l] = lockn;
              s_tauloc[l] = loctaun;
              s_tauSqrtloc[l] = sqrt(loctaun);
            }
          }
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gid = e * p_Np * p_Nvgeo + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat drdx = vgeo[gid + p_RXID * p_Np];
          const dfloat drdy = vgeo[gid + p_RYID * p_Np];
          const dfloat drdz = vgeo[gid + p_RZID * p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID * p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID * p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID * p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID * p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID * p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID * p_Np];
          const dfloat JW = vgeo[gid + p_JWID * p_Np];

          dfloat dkdr = 0, dkds = 0, dkdt = 0;
          dfloat dtaudr = 0, dtauds = 0, dtaudt = 0;
          dfloat dtauSqrtdr = 0, dtauSqrtds = 0, dtauSqrtdt = 0;

#pragma unroll p_Nq
          for (int n = 0; n < p_Nq; n++) {
            const dfloat Dr = s_D[i][n];
            const dfloat Ds = s_D[j][n];
            const dfloat Dt = s_D[k][n];

            dkdr += Dr * s_k[j][n];
            dkds += Ds * s_k[n][i];
            dkdt += Dt * s_kloc[n];

            dtaudr += Dr * s_tau[j][n];
            dtauds += Ds * s_tau[n][i];
            dtaudt += Dt * s_tauloc[n];

            dtauSqrtdr += Dr * s_tauSqrt[j][n];
            dtauSqrtds += Ds * s_tauSqrt[n][i];
            dtauSqrtdt += Dt * s_tauSqrtloc[n];
          }
          const dfloat dkdx = drdx * dkdr + dsdx * dkds + dtdx * dkdt;
          const dfloat dkdy = drdy * dkdr + dsdy * dkds + dtdy * dkdt;
          const dfloat dkdz = drdz * dkdr + dsdz * dkds + dtdz * dkdt;

          const dfloat dtaudx = drdx * dtaudr + dsdx * dtauds + dtdx * dtaudt;
          const dfloat dtaudy = drdy * dtaudr + dsdy * dtauds + dtdy * dtaudt;
          const dfloat dtaudz = drdz * dtaudr + dsdz * dtauds + dtdz * dtaudt;

          const dfloat dtauSqrtdx = drdx * dtauSqrtdr + dsdx * dtauSqrtds + dtdx * dtauSqrtdt;
          const dfloat dtauSqrtdy = drdy * dtauSqrtdr + dsdy * dtauSqrtds + dtdy * dtauSqrtdt;
          const dfloat dtauSqrtdz = drdz * dtauSqrtdr + dsdz * dtauSqrtds + dtdz * dtauSqrtdt;

          const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          XK[id] = -(dkdx * dtaudx + dkdy * dtaudy + dkdz * dtaudz);
          XT[id] = dtaudx * dtaudx + dtaudy * dtaudy + dtaudz * dtaudz;
          XTQ[id] = dtauSqrtdx * dtauSqrtdx + dtauSqrtdy * dtauSqrtdy + dtauSqrtdz * dtauSqrtdz;
        }
      }
      @barrier();
    }
  }
}

void rmax(dfloat *s_max, const dlong t, const dlong bs) {
  s_max[t] = (s_max[t] > s_max[t + bs]) ? s_max[t] : s_max[t + bs];
}

void rmin(dfloat *s_min, const dlong t, const dlong bs) {
  s_min[t] = (s_min[t] < s_min[t + bs]) ? s_min[t] : s_min[t + bs];
}

@kernel void DESLenScale(const dlong Nelements,
                         const dlong offset,
                         @ restrict const dfloat *x,
                         @ restrict const dfloat *y,
                         @ restrict const dfloat *z,
                         @ restrict dfloat *dgrd)
{
  for (dlong e = 0; e < Nelements; e++; @outer(0)) {
    const dlong Nblocks = (p_Np + p_blockSize - 1)/p_blockSize;

    const dfloat iporder = 1.0 / (p_Nq - 1.0); 

    dgrd[e] = -1e10;

    for (dlong n = 0; n < Nblocks; n++) {
      @shared dfloat s_xmax[p_blockSize];
      @shared dfloat s_xmin[p_blockSize];
      @shared dfloat s_ymax[p_blockSize];
      @shared dfloat s_ymin[p_blockSize];
      @shared dfloat s_zmax[p_blockSize];
      @shared dfloat s_zmin[p_blockSize];

      for (dlong t = 0; t < p_blockSize; ++t; @inner(0)) {
        s_xmax[t] = -1e10;
        s_xmin[t] = 1e10;
        s_ymax[t] = -1e10;
        s_ymin[t] = 1e10;
        s_zmax[t] = -1e10;
        s_zmin[t] = 1e10;
        const dlong ide = n * p_blockSize + t;
        if(ide < p_Np){
          const dlong id = e * p_Np + ide;
          s_xmax[t] = x[id];
          s_xmin[t] = x[id];
          s_ymax[t] = y[id];
          s_ymin[t] = y[id];
          s_zmax[t] = z[id];
          s_zmin[t] = z[id];
        }
      }
      @barrier();

#if p_blockSize > 512
      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 512) {
          rmax(s_xmax, t, 512);
          rmin(s_xmin, t, 512);
          rmax(s_ymax, t, 512);
          rmin(s_ymin, t, 512);
          rmax(s_zmax, t, 512);
          rmin(s_zmin, t, 512);
        }
      @barrier();
#endif

#if p_blockSize > 256
      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 256) {
          rmax(s_xmax, t, 256);
          rmin(s_xmin, t, 256);
          rmax(s_ymax, t, 256);
          rmin(s_ymin, t, 256);
          rmax(s_zmax, t, 256);
          rmin(s_zmin, t, 256);
        }
      @barrier();
#endif

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 128) {
          rmax(s_xmax, t, 128);
          rmin(s_xmin, t, 128);
          rmax(s_ymax, t, 128);
          rmin(s_ymin, t, 128);
          rmax(s_zmax, t, 128);
          rmin(s_zmin, t, 128);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 64) {
          rmax(s_xmax, t, 64);
          rmin(s_xmin, t, 64);
          rmax(s_ymax, t, 64);
          rmin(s_ymin, t, 64);
          rmax(s_zmax, t, 64);
          rmin(s_zmin, t, 64);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 32) {
          rmax(s_xmax, t, 32);
          rmin(s_xmin, t, 32);
          rmax(s_ymax, t, 32);
          rmin(s_ymin, t, 32);
          rmax(s_zmax, t, 32);
          rmin(s_zmin, t, 32);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 16) {
          rmax(s_xmax, t, 16);
          rmin(s_xmin, t, 16);
          rmax(s_ymax, t, 16);
          rmin(s_ymin, t, 16);
          rmax(s_zmax, t, 16);
          rmin(s_zmin, t, 16);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 8) {
          rmax(s_xmax, t, 8);
          rmin(s_xmin, t, 8);
          rmax(s_ymax, t, 8);
          rmin(s_ymin, t, 8);
          rmax(s_zmax, t, 8);
          rmin(s_zmin, t, 8);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 4) {
          rmax(s_xmax, t, 4);
          rmin(s_xmin, t, 4);
          rmax(s_ymax, t, 4);
          rmin(s_ymin, t, 4);
          rmax(s_zmax, t, 4);
          rmin(s_zmin, t, 4);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 2) {
          rmax(s_xmax, t, 2);
          rmin(s_xmin, t, 2);
          rmax(s_ymax, t, 2);
          rmin(s_ymin, t, 2);
          rmax(s_zmax, t, 2);
          rmin(s_zmin, t, 2);
        }
      @barrier();

      for (int t = 0; t < p_blockSize; ++t; @inner(0))
        if (t < 1) {
          const dfloat xmax = (s_xmax[0] > s_xmax[1]) ? s_xmax[0] : s_xmax[1];
          const dfloat xmin = (s_xmin[0] < s_xmin[1]) ? s_xmin[0] : s_xmin[1];
          const dfloat ymax = (s_ymax[0] > s_ymax[1]) ? s_ymax[0] : s_ymax[1];
          const dfloat ymin = (s_ymin[0] < s_ymin[1]) ? s_ymin[0] : s_ymin[1];
          const dfloat zmax = (s_zmax[0] > s_zmax[1]) ? s_zmax[0] : s_zmax[1];
          const dfloat zmin = (s_zmin[0] < s_zmin[1]) ? s_zmin[0] : s_zmin[1];

          const dfloat dxgrd = (xmax - xmin) * iporder;
          const dfloat dygrd = (ymax - ymin) * iporder;
          const dfloat dzgrd = (zmax - zmin) * iporder;

          const dfloat dd = fmax(dxgrd, dygrd);
          const dfloat dd1 = fmax(dd, dzgrd);
          dgrd[e] = fmax(dgrd[e], dd1);
        }
      @barrier();
    }
  }
}
